Language "IBAFlang"

# Statements

Syntax Stmt: statement ::= '{' statement* '}'
                    | 'print' '(' exp ')' ';'
                    | id ';'
                    | id '=' exp ';'
                    | 'return' exp? ';'
                    | 'fun' id '(' ')' '{' statement* '}'

Semantics execute[[ Stmt*:statement* ]] : => null-type

Rule execute[[ '{' Stmt* '}' ]] = scope(collateral(collect-declared-vars[[ Stmt* ]]), execute[[ Stmt* ]])
Rule execute[[ 'print' '(' Exp ')' ';' ]] = print eval-exp[[ Exp ]]
Rule execute[[ Id ';' ]] = assign(bound id[[ Id ]], 0)
Rule execute[[ Id '=' Exp ';' ]] = assign(bound id[[ Id ]], eval-exp[[ Exp ]])
Rule execute[[ 'return' Exp ';' ]] = return eval-exp[[ Exp ]]
Rule execute[[ 'return' ';' ]] = return null
Rule execute[[ 'fun' Id '(' ')' '{' Stmt* '}' ]] = null

Rule execute[[ ]] = null
Rule execute[[ Stmt Stmt+ ]] = sequential(execute[[ Stmt ]], execute[[ Stmt+ ]])




# Handling variable declarations

Semantics collect-declared-vars[[ Stmt*:statement* ]] : (=>environments)+

Rule collect-declared-vars[[ Id '=' Exp ';' ]] = bind(id[[ Id ]], 
    allocate-variable(integers)
)
Rule collect-declared-vars[[ Id ';' ]] = bind(id[[ Id ]], 
    allocate-variable(integers)
)
Rule collect-declared-vars[[ 'fun' Id '(' ')' '{' Stmt* '}' ]] = bind(id[[ Id ]], 
    function abstraction(execute[[ '{' Stmt* '}' ]])
)
Rule collect-declared-vars[[ ]] = map()
Rule collect-declared-vars[[ Stmt ]] = map()
Rule collect-declared-vars[[ Stmt1 Stmt2 Stmt* ]] = collect-declared-vars[[ Stmt1 ]], collect-declared-vars[[ Stmt2 ]], collect-declared-vars[[ Stmt* ]]












